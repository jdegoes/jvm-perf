/**
 * TOOLS
 *
 * JMH is an incredibly useful tool for benchmarking and optimizing code. However, although JMH is
 * qute useful, it cannot tell you why your code is slow or tell you which parts of your code you
 * should benchmark.
 *
 * In this section, you will explore several tools that you can use both to help identify
 * performance bottlenecks, as well as to understand why an identified section of code is slow.
 */
package net.degoes.tools

import org.openjdk.jmh.annotations._
import org.openjdk.jmh.infra.Blackhole
import java.util.concurrent.TimeUnit
import java.util.ArrayList

/**
 * EXERCISE 1
 *
 * Use the flag "-XX:+PrintCompilation" to print out the JIT compilation of the benchmark. Is the
 * `fib` method compiled to native code by HotSpot?
 */
@State(Scope.Thread)
@OutputTimeUnit(TimeUnit.MILLISECONDS)
@BenchmarkMode(Array(Mode.Throughput))
@Warmup(iterations = 5, time = 1, timeUnit = TimeUnit.SECONDS)
@Measurement(iterations = 5, time = 1, timeUnit = TimeUnit.SECONDS)
@Fork(value = 1, jvmArgsAppend = Array())
@Threads(16)
class PrintCompilationBenchmark {
  @Param(Array("10", "20"))
  var depth: Int = _

  def fib(n: Int): Int =
    if (n <= 1) 1 else fib(n - 1) + fib(n - 2)

  @Benchmark
  def fib(blackhole: Blackhole): Unit =
    blackhole.consume(fib(depth))
}

/**
 * EXERCISE 2
 *
 * Use the flag "-XX:+PrintInlining" (together with "-XX:+UnlockDiagnosticVMOptions") to print out
 * the inlining of the benchmark.
 *
 * Is the `makeSize` method inlined by HotSpot?
 */
@State(Scope.Thread)
@OutputTimeUnit(TimeUnit.MILLISECONDS)
@BenchmarkMode(Array(Mode.Throughput))
@Warmup(iterations = 5, time = 1, timeUnit = TimeUnit.SECONDS)
@Measurement(iterations = 5, time = 1, timeUnit = TimeUnit.SECONDS)
@Fork(value = 1, jvmArgsAppend = Array())
@Threads(16)
class PrintInliningBenchmark {
  @Param(Array("100", "1000", "10000"))
  var size: Int = _

  def makeSize(i: Int): Size = Size(i)

  @Benchmark
  def benchmark(blackhole: Blackhole): Unit = {
    var i   = 0
    var sum = 0
    while (i < size) {
      val size = makeSize(i)
      sum = sum + size.value
      i = i + 1
    }
    blackhole.consume(sum)
  }

  case class Size(value: Int)
}

/**
 * EXERCISE 3
 *
 * Profilers can be incredibly useful for identifying performance bottlenecks. Even though it is
 * hard to optimize against a profiling, a profiler can help you identify the most expensive
 * sections of code (in terms of CPU or memory), which you can then benchmark and optimize.
 *
 * In this exercise, you will take your benchmark tool of choice to identify performance bottlenecks
 * in the provided code. You can use this information in the next module.
 */
object ProfilerExample {
  def main(args: Array[String]): Unit = {
    import zio.Chunk
    import net.degoes.project.dataset1._

    val Size = 10_000

    val rng = new scala.util.Random(0L)

    val start: Field  = Field("start")
    val end: Field    = Field("end")
    val netPay: Field = Field("netPay")

    val dataset = Dataset(Chunk.fill(Size) {
      val start  = rng.between(0, 360)
      val end    = rng.between(start, 360)
      val netPay = rng.between(20000, 60000)

      Row(
        Map(
          "start"  -> Value.Integer(start),
          "end"    -> Value.Integer(end),
          "netPay" -> Value.Integer(netPay)
        )
      )
    })

    var i = 0L
    while (i < 1_000_000) {
      (dataset(start) + dataset(end)) / dataset(netPay)
      i = i + 1L
    }
  }
}

/**
 * GRADUATION PROJECT
 *
 * Sometimes, you need to see something closer to the raw bytecode that your compiler generates.
 * This is especially true when you are using higher-level languages like Kotlin, Scala, and
 * Clojure, because these languages have features that do not map directly to JVM bytecode.
 *
 * In order to do this, you can use the `javap` method with the following flags:
 *
 *   - `-c` prints out the bytecode
 *   - `-l` prints out line numbers
 *   - `-p` prints out private methods
 *   - `-s` prints out internal type signatures
 *   - `-v` prints out verbose information
 *
 * In this exercise, you will use `javap` to see the bytecode generated by the Scala compiler for
 * the provided benchmark. Walk through the reverse-engineered code and try to understand any
 * sources of inefficiency that you see. Revise the inefficient code until `javap` shows you cleanly
 * generated code that you would expect to be fast.
 */
@State(Scope.Thread)
@OutputTimeUnit(TimeUnit.SECONDS)
@BenchmarkMode(Array(Mode.Throughput))
@Warmup(iterations = 5, time = 1, timeUnit = TimeUnit.SECONDS)
@Measurement(iterations = 5, time = 1, timeUnit = TimeUnit.SECONDS)
@Fork(value = 1, jvmArgsAppend = Array("-XX:-DoEscapeAnalysis", "-XX:-Inline"))
@Threads(16)
class JavapBenchmark {
  val rng = new scala.util.Random(0L)

  @Param(Array("1000", "10000", "100000"))
  var size: Int = _

  var program: State[Int, Int] = _

  @Setup(Level.Trial)
  def setup(): Unit =
    program = (0 until size).foldLeft(State.succeed[Int, Int](0)) { (acc, _) =>
      for {
        _ <- acc
        i <- State.getState[Int]
        _ <- State.setState(i + 1)
      } yield i + 1
    }

  @Benchmark
  def benchmark(blackhole: Blackhole): Unit =
    program.execute(0)

  sealed trait State[S, +A] {
    def flatMap[B](f: A => State[S, B]): State[S, B] = State.FlatMap(this, f)

    def map[B](f: A => B): State[S, B] = flatMap(f andThen State.succeed)

    def execute(state0: S): (S, A) = {
      def erase(state: State[S, _]): State[S, Any] = state.asInstanceOf[State[S, Any]]

      def eraseK[A, B](f: A => State[S, B]): A => State[S, Any] = f.asInstanceOf[A => State[S, Any]]

      def loop[A](): (S, A) = {
        var next: State[S, Any]                     = erase(this)
        var state: S                                = state0
        var result: A                               = null.asInstanceOf[A]
        var stack: List[Any => State[S, Any]]       = Nil
        def continueWith(value: Any): State[S, Any] =
          stack match {
            case Nil         =>
              result = value.asInstanceOf[A]
              null
            case f :: stack0 =>
              stack = stack0
              f(value)
          }

        while (next != null)
          next = next match {
            case State.GetState()        =>
              continueWith(state)
            case State.SetState(s)       =>
              state = s
              continueWith(())
            case State.FlatMap(state, f) =>
              stack = eraseK(f) :: stack
              state
            case State.Succeed(a)        =>
              continueWith(a)
          }

        (state, result)
      }

      loop()
    }
  }
  object State              {
    case class GetState[S]()                                             extends State[S, S]
    case class SetState[S](s: S)                                         extends State[S, Unit]
    case class FlatMap[S, A, B](state: State[S, A], f: A => State[S, B]) extends State[S, B]
    case class Succeed[S, A](a: A)                                       extends State[S, A]

    def succeed[S, A](a: A): State[S, A] = Succeed(a)

    def getState[S]: State[S, S] = GetState()

    def setState[S](s: S): State[S, Unit] = SetState(s)
  }
}
